<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Order Book Indodax - Hyper Speed</title>
    
    <!-- DNS Prefetch & Preconnect untuk speed maksimal -->
    <link rel="dns-prefetch" href="//indodax.com">
    <link rel="dns-prefetch" href="//corsproxy.io">
    <link rel="preconnect" href="https://indodax.com" crossorigin>
    <link rel="preconnect" href="https://corsproxy.io" crossorigin>
    
    <style>
        *{box-sizing:border-box;margin:0;padding:0}
        :root{--bg:#0a0a12;--card:#12121f;--border:#1e1e32;--text:#e0e0e0;--muted:#666;--buy:#00ff88;--sell:#ff4466;--accent:#00d4ff;--warning:#ffaa00}
        html{-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility}
        body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',system-ui,sans-serif;background:var(--bg);color:var(--text);min-height:100vh;padding:8px;font-size:13px}
        
        /* GPU Acceleration */
        .gpu{transform:translateZ(0);will-change:transform;backface-visibility:hidden}
        
        /* Header */
        .header{text-align:center;padding:10px 0;position:sticky;top:0;z-index:100;background:var(--bg);border-bottom:1px solid var(--border)}
        .logo{font-size:20px;font-weight:800;background:linear-gradient(135deg,var(--accent),var(--buy));-webkit-background-clip:text;-webkit-text-fill-color:transparent;display:inline-flex;align-items:center;gap:8px}
        .badge{font-size:9px;padding:2px 6px;background:var(--accent);color:#000;border-radius:10px;font-weight:700;animation:pulse 2s infinite;-webkit-text-fill-color:#000}
        @keyframes pulse{0%,100%{opacity:1}50%{opacity:.7}}
        .speed-indicator{display:flex;justify-content:center;gap:15px;margin-top:8px;font-size:10px;color:var(--muted)}
        .speed-indicator span{display:flex;align-items:center;gap:4px}
        .dot{width:6px;height:6px;border-radius:50%;background:var(--buy);animation:blink 1s infinite}
        .dot.slow{background:var(--warning)}
        .dot.error{background:var(--sell);animation:none}
        @keyframes blink{0%,100%{opacity:1}50%{opacity:.3}}
        
        /* Controls */
        .controls{display:flex;flex-wrap:wrap;justify-content:center;align-items:center;gap:8px;padding:10px;background:var(--card);border-radius:10px;margin:10px 0}
        .select-wrap{position:relative;min-width:220px}
        .select-wrap select{width:100%;padding:10px 35px 10px 12px;border:1px solid var(--border);border-radius:6px;background:var(--bg);color:var(--text);font-size:13px;cursor:pointer;appearance:none}
        .select-wrap::after{content:'‚ñº';position:absolute;right:12px;top:50%;transform:translateY(-50%);font-size:10px;color:var(--muted);pointer-events:none}
        .btn{padding:10px 20px;border:none;border-radius:6px;font-weight:600;cursor:pointer;transition:all .15s;font-size:12px}
        .btn-primary{background:var(--accent);color:#000}
        .btn-primary:hover{filter:brightness(1.2);transform:scale(1.02)}
        .btn-primary:active{transform:scale(.98)}
        .btn:disabled{opacity:.5;cursor:not-allowed;transform:none!important}
        .status-badge{padding:6px 12px;border-radius:20px;font-size:11px;font-weight:600;display:inline-flex;align-items:center;gap:6px}
        .status-badge.loading{background:rgba(255,170,0,.15);color:var(--warning)}
        .status-badge.success{background:rgba(0,255,136,.15);color:var(--buy)}
        .status-badge.error{background:rgba(255,68,102,.15);color:var(--sell)}
        .spinner{width:10px;height:10px;border:2px solid transparent;border-top-color:currentColor;border-radius:50%;animation:spin .6s linear infinite}
        @keyframes spin{to{transform:rotate(360deg)}}
        
        /* Price Display */
        .price-bar{display:grid;grid-template-columns:1fr auto 1fr;gap:10px;padding:12px 15px;background:linear-gradient(135deg,rgba(0,255,136,.05),rgba(255,68,102,.05));border-radius:10px;margin-bottom:10px;align-items:center}
        .price-item{text-align:center}
        .price-item:first-child{text-align:left}
        .price-item:last-child{text-align:right}
        .price-label{font-size:10px;color:var(--muted);text-transform:uppercase;letter-spacing:.5px}
        .price-value{font-size:18px;font-weight:700;font-family:'SF Mono',Consolas,monospace;margin-top:2px}
        .price-value.buy{color:var(--buy)}
        .price-value.sell{color:var(--sell)}
        .price-value.spread{color:var(--warning);font-size:14px}
        
        /* Tables Container */
        .tables{display:grid;grid-template-columns:repeat(auto-fit,minmax(340px,1fr));gap:10px}
        .table-card{background:var(--card);border-radius:10px;border:1px solid var(--border);overflow:hidden;contain:layout style paint}
        .table-header{display:flex;justify-content:space-between;align-items:center;padding:12px 15px;border-bottom:2px solid}
        .table-card.buy .table-header{border-color:var(--buy)}
        .table-card.sell .table-header{border-color:var(--sell)}
        .table-title{font-weight:700;font-size:13px;display:flex;align-items:center;gap:6px}
        .table-card.buy .table-title{color:var(--buy)}
        .table-card.sell .table-title{color:var(--sell)}
        .count-badge{font-size:11px;padding:3px 10px;border-radius:12px;font-weight:600}
        .table-card.buy .count-badge{background:rgba(0,255,136,.1);color:var(--buy)}
        .table-card.sell .count-badge{background:rgba(255,68,102,.1);color:var(--sell)}
        
        /* Virtual Scroll Container */
        .table-scroll{height:350px;overflow-y:auto;overflow-x:hidden;contain:strict}
        .table-scroll::-webkit-scrollbar{width:4px}
        .table-scroll::-webkit-scrollbar-track{background:var(--bg)}
        .table-scroll::-webkit-scrollbar-thumb{background:var(--border);border-radius:2px}
        
        /* Table */
        table{width:100%;border-collapse:collapse;table-layout:fixed}
        th{position:sticky;top:0;background:var(--bg);padding:8px 10px;font-size:10px;text-transform:uppercase;letter-spacing:.5px;color:var(--muted);font-weight:600;text-align:right;z-index:1}
        th:first-child{width:35px;text-align:center}
        td{padding:5px 10px;font-size:12px;text-align:right;border-bottom:1px solid rgba(255,255,255,.02);font-family:'SF Mono',Consolas,monospace;font-variant-numeric:tabular-nums}
        td:first-child{text-align:center;color:var(--muted);font-size:10px}
        .table-card.buy td:nth-child(2){color:var(--buy);font-weight:600}
        .table-card.sell td:nth-child(2){color:var(--sell);font-weight:600}
        tr{transition:background .1s}
        tr:hover{background:rgba(255,255,255,.03)}
        
        /* Depth Bar */
        .depth-bar{position:absolute;top:0;bottom:0;opacity:.1;pointer-events:none}
        .table-card.buy .depth-bar{right:0;background:linear-gradient(to left,var(--buy),transparent)}
        .table-card.sell .depth-bar{right:0;background:linear-gradient(to left,var(--sell),transparent)}
        td.has-depth{position:relative}
        
        /* Summary */
        .summary{padding:10px 15px;background:rgba(0,0,0,.2);font-size:11px}
        .summary-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
        .summary-item{text-align:center}
        .summary-label{color:var(--muted);font-size:9px;text-transform:uppercase}
        .summary-value{font-weight:700;margin-top:2px;font-family:'SF Mono',Consolas,monospace}
        .table-card.buy .summary-value{color:var(--buy)}
        .table-card.sell .summary-value{color:var(--sell)}
        
        /* Footer */
        .footer{text-align:center;padding:15px;color:var(--muted);font-size:10px}
        .footer a{color:var(--accent);text-decoration:none}
        .perf-stats{display:flex;justify-content:center;gap:20px;margin-top:5px;font-family:'SF Mono',Consolas,monospace}
        .perf-stat{display:flex;align-items:center;gap:4px}
        .perf-stat.fast{color:var(--buy)}
        .perf-stat.medium{color:var(--warning)}
        .perf-stat.slow{color:var(--sell)}
        
        /* Loading Skeleton */
        .skeleton{background:linear-gradient(90deg,var(--bg) 25%,var(--border) 50%,var(--bg) 75%);background-size:200% 100%;animation:shimmer .8s infinite linear}
        @keyframes shimmer{0%{background-position:200% 0}100%{background-position:-200% 0}}
        .skeleton-row{height:24px;margin:3px 10px;border-radius:3px}
        
        /* Responsive */
        @media(max-width:768px){
            .tables{grid-template-columns:1fr}
            .price-bar{grid-template-columns:1fr 1fr;gap:8px}
            .price-item:first-child,.price-item:last-child{text-align:center}
            .price-item.spread-item{grid-column:span 2}
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="logo">
            ‚ö° HYPER ORDER BOOK
            <span class="badge">ULTRA FAST</span>
        </div>
        <div class="speed-indicator">
            <span><span class="dot" id="wsStatus"></span> <span id="wsText">Connecting...</span></span>
            <span>üöÄ <span id="latency">--</span>ms</span>
            <span>üìä <span id="rps">0</span> req/s</span>
        </div>
    </div>
    
    <div class="controls">
        <div class="select-wrap">
            <select id="pairSelect"></select>
        </div>
        <button class="btn btn-primary" id="refreshBtn">‚ö° REFRESH</button>
        <span class="status-badge" id="status"></span>
    </div>
    
    <div class="price-bar" id="priceBar" style="display:none">
        <div class="price-item">
            <div class="price-label">Best Bid</div>
            <div class="price-value buy" id="bestBid">-</div>
        </div>
        <div class="price-item spread-item">
            <div class="price-label">Spread</div>
            <div class="price-value spread" id="spread">-</div>
        </div>
        <div class="price-item">
            <div class="price-label">Best Ask</div>
            <div class="price-value sell" id="bestAsk">-</div>
        </div>
    </div>
    
    <div class="tables">
        <div class="table-card buy">
            <div class="table-header">
                <span class="table-title">üìà BUY ORDERS</span>
                <span class="count-badge" id="buyCount">0</span>
            </div>
            <div class="table-scroll gpu" id="buyScroll">
                <table>
                    <thead><tr><th>#</th><th>Price (IDR)</th><th>Amount</th><th>Total</th></tr></thead>
                    <tbody id="buyBody"></tbody>
                </table>
            </div>
            <div class="summary">
                <div class="summary-grid">
                    <div class="summary-item"><div class="summary-label">Orders</div><div class="summary-value" id="buyOrders">-</div></div>
                    <div class="summary-item"><div class="summary-label">Volume</div><div class="summary-value" id="buyVol">-</div></div>
                    <div class="summary-item"><div class="summary-label">Value</div><div class="summary-value" id="buyVal">-</div></div>
                </div>
            </div>
        </div>
        
        <div class="table-card sell">
            <div class="table-header">
                <span class="table-title">üìâ SELL ORDERS</span>
                <span class="count-badge" id="sellCount">0</span>
            </div>
            <div class="table-scroll gpu" id="sellScroll">
                <table>
                    <thead><tr><th>#</th><th>Price (IDR)</th><th>Amount</th><th>Total</th></tr></thead>
                    <tbody id="sellBody"></tbody>
                </table>
            </div>
            <div class="summary">
                <div class="summary-grid">
                    <div class="summary-item"><div class="summary-label">Orders</div><div class="summary-value" id="sellOrders">-</div></div>
                    <div class="summary-item"><div class="summary-label">Volume</div><div class="summary-value" id="sellVol">-</div></div>
                    <div class="summary-item"><div class="summary-label">Value</div><div class="summary-value" id="sellVal">-</div></div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="footer">
        <div>Last Update: <span id="lastUpdate">-</span> | Data by <a href="https://indodax.com" target="_blank">Indodax</a></div>
        <div class="perf-stats">
            <span class="perf-stat" id="fetchTime">‚è±Ô∏è Fetch: --ms</span>
            <span class="perf-stat" id="renderTime">üé® Render: --ms</span>
            <span class="perf-stat" id="totalTime">‚ö° Total: --ms</span>
        </div>
    </div>

<script>
// ============================================
// üöÄ HYPER SPEED ENGINE v3.0
// ============================================

const CONFIG = {
    PROXIES: [
        url => `https://corsproxy.io/?${encodeURIComponent(url)}`,
        url => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
        url => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`,
    ],
    TIMEOUT: 4000,
    MAX_ROWS: 150,
    CACHE_TTL: 3600000, // 1 jam
    DEBOUNCE: 100
};

// ============================================
// üíæ TURBO CACHE - IndexedDB + Memory
// ============================================
class TurboCache {
    constructor() {
        this.mem = new Map();
        this.dbName = 'HyperOrderBook';
        this.dbReady = this.initDB();
    }
    
    async initDB() {
        return new Promise((resolve, reject) => {
            const req = indexedDB.open(this.dbName, 1);
            req.onerror = () => resolve(null);
            req.onsuccess = () => resolve(req.result);
            req.onupgradeneeded = e => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains('cache')) {
                    db.createObjectStore('cache', { keyPath: 'key' });
                }
            };
        });
    }
    
    async get(key) {
        // Memory first (fastest)
        if (this.mem.has(key)) {
            const item = this.mem.get(key);
            if (Date.now() < item.exp) return item.data;
            this.mem.delete(key);
        }
        
        // IndexedDB fallback
        const db = await this.dbReady;
        if (!db) return null;
        
        return new Promise(resolve => {
            try {
                const tx = db.transaction('cache', 'readonly');
                const store = tx.objectStore('cache');
                const req = store.get(key);
                req.onsuccess = () => {
                    const item = req.result;
                    if (item && Date.now() < item.exp) {
                        this.mem.set(key, item); // Promote to memory
                        resolve(item.data);
                    } else {
                        resolve(null);
                    }
                };
                req.onerror = () => resolve(null);
            } catch (e) { resolve(null); }
        });
    }
    
    async set(key, data, ttl = CONFIG.CACHE_TTL) {
        const item = { key, data, exp: Date.now() + ttl };
        this.mem.set(key, item);
        
        const db = await this.dbReady;
        if (!db) return;
        
        try {
            const tx = db.transaction('cache', 'readwrite');
            tx.objectStore('cache').put(item);
        } catch (e) {}
    }
}

// ============================================
// ‚ö° HYPER FETCH - Race All Proxies
// ============================================
class HyperFetch {
    constructor() {
        this.proxyStats = CONFIG.PROXIES.map(() => ({ success: 0, fail: 0, avgTime: 1000 }));
    }
    
    async fetch(url) {
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), CONFIG.TIMEOUT);
        
        // Sort proxies by performance
        const sortedProxies = CONFIG.PROXIES
            .map((fn, i) => ({ fn, i, score: this.proxyStats[i].avgTime * (1 + this.proxyStats[i].fail / 10) }))
            .sort((a, b) => a.score - b.score);
        
        // Race all proxies simultaneously!
        const promises = sortedProxies.map(async ({ fn, i }) => {
            const start = performance.now();
            try {
                const res = await fetch(fn(url), {
                    signal: controller.signal,
                    headers: { 'Accept': 'application/json' }
                });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const data = await res.json();
                const elapsed = performance.now() - start;
                
                // Update stats
                this.proxyStats[i].success++;
                this.proxyStats[i].avgTime = (this.proxyStats[i].avgTime * 0.7) + (elapsed * 0.3);
                
                return { data, elapsed, proxy: i };
            } catch (e) {
                this.proxyStats[i].fail++;
                throw e;
            }
        });
        
        try {
            const result = await Promise.any(promises);
            clearTimeout(timeout);
            controller.abort(); // Cancel other requests
            return result;
        } catch (e) {
            clearTimeout(timeout);
            throw new Error('All proxies failed');
        }
    }
}

// ============================================
// üé® HYPER RENDERER - Optimized DOM
// ============================================
class HyperRenderer {
    constructor() {
        this.buyBody = document.getElementById('buyBody');
        this.sellBody = document.getElementById('sellBody');
        this.rowPool = { buy: [], sell: [] };
        this.lastBuyData = null;
        this.lastSellData = null;
    }
    
    // Pre-create row elements for reuse
    createRow() {
        const tr = document.createElement('tr');
        tr.innerHTML = '<td></td><td></td><td></td><td class="has-depth"><span class="depth-bar"></span><span class="val"></span></td>';
        return tr;
    }
    
    getRow(type) {
        if (this.rowPool[type].length > 0) {
            return this.rowPool[type].pop();
        }
        return this.createRow();
    }
    
    returnRow(type, row) {
        if (this.rowPool[type].length < 200) {
            this.rowPool[type].push(row);
        }
    }
    
    // Ultra-fast render with DocumentFragment and diff
    render(type, data, coinName, maxDepth) {
        const body = type === 'buy' ? this.buyBody : this.sellBody;
        const lastData = type === 'buy' ? this.lastBuyData : this.lastSellData;
        
        // Skip if data unchanged
        if (lastData && JSON.stringify(data.slice(0, 50)) === JSON.stringify(lastData.slice(0, 50))) {
            return;
        }
        
        if (type === 'buy') this.lastBuyData = data.slice(0, 50);
        else this.lastSellData = data.slice(0, 50);
        
        const fragment = document.createDocumentFragment();
        const display = data.slice(0, CONFIG.MAX_ROWS);
        
        let totalVol = 0, totalVal = 0;
        
        // Calculate totals first for depth bars
        for (let i = 0; i < data.length; i++) {
            totalVol += +data[i][1];
            totalVal += (+data[i][0]) * (+data[i][1]);
        }
        
        // Build rows
        for (let i = 0; i < display.length; i++) {
            const [price, amount] = display[i];
            const p = +price, a = +amount, t = p * a;
            const depthPct = Math.min((t / maxDepth) * 100, 100);
            
            const row = this.getRow(type);
            const cells = row.cells;
            
            cells[0].textContent = i + 1;
            cells[1].textContent = this.formatPrice(p);
            cells[2].textContent = this.formatAmount(a);
            cells[3].querySelector('.val').textContent = this.formatCompact(t);
            cells[3].querySelector('.depth-bar').style.width = depthPct + '%';
            
            fragment.appendChild(row);
        }
        
        // Return old rows to pool
        while (body.firstChild) {
            const row = body.firstChild;
            body.removeChild(row);
            this.returnRow(type, row);
        }
        
        // Single DOM update
        body.appendChild(fragment);
        
        // Update summary
        document.getElementById(type + 'Count').textContent = data.length;
        document.getElementById(type + 'Orders').textContent = data.length;
        document.getElementById(type + 'Vol').textContent = this.formatAmount(totalVol) + ' ' + coinName;
        document.getElementById(type + 'Val').textContent = this.formatValue(totalVal);
    }
    
    showSkeleton(body, count = 10) {
        body.innerHTML = Array(count).fill(
            '<tr><td colspan="4"><div class="skeleton skeleton-row"></div></td></tr>'
        ).join('');
    }
    
    formatPrice(n) {
        return n >= 1000 ? n.toLocaleString('id-ID') : n.toFixed(n < 1 ? 8 : 2);
    }
    
    formatAmount(n) {
        if (n >= 1e9) return (n / 1e9).toFixed(2) + 'B';
        if (n >= 1e6) return (n / 1e6).toFixed(2) + 'M';
        if (n >= 1e3) return (n / 1e3).toFixed(2) + 'K';
        if (n >= 1) return n.toFixed(2);
        if (n >= 0.0001) return n.toFixed(4);
        return n.toFixed(8);
    }
    
    formatCompact(n) {
        if (n >= 1e12) return (n / 1e12).toFixed(1) + 'T';
        if (n >= 1e9) return (n / 1e9).toFixed(1) + 'B';
        if (n >= 1e6) return (n / 1e6).toFixed(1) + 'M';
        if (n >= 1e3) return (n / 1e3).toFixed(0) + 'K';
        return n.toFixed(0);
    }
    
    formatValue(n) {
        if (n >= 1e12) return 'Rp' + (n / 1e12).toFixed(2) + 'T';
        if (n >= 1e9) return 'Rp' + (n / 1e9).toFixed(2) + 'M';
        if (n >= 1e6) return 'Rp' + (n / 1e6).toFixed(2) + 'Jt';
        return 'Rp' + n.toLocaleString('id-ID');
    }
}

// ============================================
// üéÆ MAIN APPLICATION
// ============================================
class HyperOrderBook {
    constructor() {
        this.cache = new TurboCache();
        this.fetcher = new HyperFetch();
        this.renderer = new HyperRenderer();
        
        this.pairs = [];
        this.currentPair = '';
        this.coinName = '';
        this.requestCount = 0;
        this.lastRequestTime = Date.now();
        
        this.elements = {
            select: document.getElementById('pairSelect'),
            refreshBtn: document.getElementById('refreshBtn'),
            status: document.getElementById('status'),
            wsStatus: document.getElementById('wsStatus'),
            wsText: document.getElementById('wsText'),
            latency: document.getElementById('latency'),
            rps: document.getElementById('rps'),
            priceBar: document.getElementById('priceBar'),
            bestBid: document.getElementById('bestBid'),
            bestAsk: document.getElementById('bestAsk'),
            spread: document.getElementById('spread'),
            buyBody: document.getElementById('buyBody'),
            sellBody: document.getElementById('sellBody'),
            lastUpdate: document.getElementById('lastUpdate'),
            fetchTime: document.getElementById('fetchTime'),
            renderTime: document.getElementById('renderTime'),
            totalTime: document.getElementById('totalTime')
        };
        
        this.init();
    }
    
    async init() {
        this.setStatus('Initializing...', 'loading');
        this.renderer.showSkeleton(this.elements.buyBody);
        this.renderer.showSkeleton(this.elements.sellBody);
        
        // Start RPS counter
        setInterval(() => {
            const elapsed = (Date.now() - this.lastRequestTime) / 1000;
            const rps = elapsed > 0 ? (this.requestCount / elapsed).toFixed(1) : 0;
            this.elements.rps.textContent = rps;
            if (elapsed > 5) {
                this.requestCount = 0;
                this.lastRequestTime = Date.now();
            }
        }, 1000);
        
        try {
            await this.loadPairs();
            await this.loadOrderBook(this.currentPair);
            
            this.elements.wsStatus.classList.remove('slow', 'error');
            this.elements.wsText.textContent = 'Connected';
        } catch (e) {
            this.setStatus('‚ùå ' + e.message, 'error');
            this.elements.wsStatus.classList.add('error');
            this.elements.wsText.textContent = 'Error';
        }
        
        // Event listeners
        this.elements.select.onchange = () => this.loadOrderBook(this.elements.select.value);
        this.elements.refreshBtn.onclick = () => this.loadOrderBook(this.currentPair);
    }
    
    async loadPairs() {
        // Try cache first
        let pairs = await this.cache.get('pairs');
        
        if (!pairs) {
            this.setStatus('Loading pairs...', 'loading');
            const result = await this.fetcher.fetch('https://indodax.com/api/pairs');
            pairs = result.data.sort((a, b) => a.description.localeCompare(b.description));
            await this.cache.set('pairs', pairs);
        }
        
        this.pairs = pairs;
        this.elements.select.innerHTML = pairs.map(p => 
            `<option value="${p.id}">${p.description} (${p.id.toUpperCase()})</option>`
        ).join('');
        
        // Default to BTC
        const btc = pairs.find(p => p.id === 'btcidr');
        this.currentPair = btc ? btc.id : pairs[0].id;
        this.elements.select.value = this.currentPair;
    }
    
    async loadOrderBook(pairId) {
        this.currentPair = pairId;
        const pair = this.pairs.find(p => p.id === pairId);
        this.coinName = pair ? pair.description.split('/')[0].trim() : pairId.replace('idr', '').toUpperCase();
        
        this.elements.refreshBtn.disabled = true;
        this.setStatus('Loading...', 'loading');
        this.elements.wsStatus.classList.add('slow');
        this.elements.wsStatus.classList.remove('error');
        
        const totalStart = performance.now();
        
        try {
            // Fetch
            const fetchStart = performance.now();
            const result = await this.fetcher.fetch(`https://indodax.com/api/depth/${pairId}`);
            const fetchTime = performance.now() - fetchStart;
            this.requestCount++;
            
            const { buy = [], sell = [] } = result.data;
            
            // Update latency
            this.elements.latency.textContent = Math.round(result.elapsed);
            this.elements.fetchTime.textContent = `‚è±Ô∏è Fetch: ${Math.round(fetchTime)}ms`;
            this.elements.fetchTime.className = 'perf-stat ' + this.getSpeedClass(fetchTime);
            
            // Update prices
            if (buy.length && sell.length) {
                const bestBid = +buy[0][0];
                const bestAsk = +sell[0][0];
                const spread = bestAsk - bestBid;
                const spreadPct = ((spread / bestAsk) * 100).toFixed(3);
                
                this.elements.bestBid.textContent = bestBid.toLocaleString('id-ID');
                this.elements.bestAsk.textContent = bestAsk.toLocaleString('id-ID');
                this.elements.spread.textContent = `${spread.toLocaleString('id-ID')} (${spreadPct}%)`;
                this.elements.priceBar.style.display = 'grid';
            }
            
            // Render - use requestAnimationFrame for smooth rendering
            const renderStart = performance.now();
            
            // Calculate max depth for depth bars
            const maxBuyDepth = buy.slice(0, 20).reduce((sum, r) => sum + (+r[0] * +r[1]), 0) / 20;
            const maxSellDepth = sell.slice(0, 20).reduce((sum, r) => sum + (+r[0] * +r[1]), 0) / 20;
            
            requestAnimationFrame(() => {
                this.renderer.render('buy', buy, this.coinName, maxBuyDepth);
                this.renderer.render('sell', sell, this.coinName, maxSellDepth);
                
                const renderTime = performance.now() - renderStart;
                const totalTime = performance.now() - totalStart;
                
                this.elements.renderTime.textContent = `üé® Render: ${Math.round(renderTime)}ms`;
                this.elements.renderTime.className = 'perf-stat ' + this.getSpeedClass(renderTime);
                
                this.elements.totalTime.textContent = `‚ö° Total: ${Math.round(totalTime)}ms`;
                this.elements.totalTime.className = 'perf-stat ' + this.getSpeedClass(totalTime);
                
                this.elements.lastUpdate.textContent = new Date().toLocaleTimeString('id-ID') + 
                    ` | ${buy.length + sell.length} orders`;
            });
            
            this.setStatus('‚úì Ready', 'success');
            this.elements.wsStatus.classList.remove('slow', 'error');
            
        } catch (e) {
            console.error(e);
            this.setStatus('‚ùå ' + e.message, 'error');
            this.elements.wsStatus.classList.add('error');
            this.elements.wsStatus.classList.remove('slow');
            
            this.elements.buyBody.innerHTML = `<tr><td colspan="4" style="text-align:center;padding:20px;color:var(--sell)">
                ‚ùå Failed to load<br><small>${e.message}</small>
            </td></tr>`;
            this.elements.sellBody.innerHTML = this.elements.buyBody.innerHTML;
        }
        
        this.elements.refreshBtn.disabled = false;
    }
    
    getSpeedClass(ms) {
        if (ms < 100) return 'fast';
        if (ms < 500) return 'medium';
        return 'slow';
    }
    
    setStatus(text, type) {
        const el = this.elements.status;
        el.className = 'status-badge ' + type;
        if (type === 'loading') {
            el.innerHTML = `<span class="spinner"></span> ${text}`;
        } else {
            el.textContent = text;
        }
        
        if (type === 'success') {
            setTimeout(() => {
                el.textContent = '';
                el.className = 'status-badge';
            }, 2000);
        }
    }
}

// ============================================
// üöÄ LAUNCH!
// ============================================
document.addEventListener('DOMContentLoaded', () => {
    new HyperOrderBook();
});
</script>
</body>
</html>
